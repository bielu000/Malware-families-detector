//
// Created by pp on 10.01.19.
//

#include "../includes/DetectionEngine.hpp"
#include "../includes/Histogram.hpp"
#include "../../exception.hpp"
#include "../../utility/Uuid.hpp"

struct DetectorExecutionLog
{
    std::vector<Sample> invalidSamples;
};

void DetectionEngine::train(const std::unique_ptr<Dataset> &dataset)
{
    if (!isInitialized()) {
        throw app_exception(errors::codes::engine_not_initialized);
    }

    auto tracker = DetectorExecutionLog();

    // --- START --- //
    // --- STAGE 1 --- Compute features /
    _bus->event(TrainingStarted());
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::FEATURES_COMPUTATION));

    cv::Mat descriptors;
    cv::Mat labels;
    auto samples = dataset->getSamples();

    for (auto it = samples.begin(); it != samples.end(); ++it) {
        it->computeFeatures(_featuresExtractor);

        if (it->countDescriptors() < _clusterClassifier->getClustersCount()) {
            tracker.invalidSamples.push_back(*it);
            samples.erase(it);
            continue;
        }
        descriptors.push_back(it->getDescriptors());
    }

    for (auto& s : samples) {
        labels.push_back(s.getLabelId());
    }
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::FEATURES_COMPUTATION));


    // --- STAGE 2 --- Cluster features
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLUSTERING));
    auto featuresClusters = _clusterClassifier->cluster(descriptors);
    _clusterClassifier->train(descriptors, featuresClusters);
    featuresClusters = _clusterClassifier->predict(descriptors);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLUSTERING));


    // --- STAGE 3 --- Build vocabulary
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::VOCABULARY_COMPUTATION));
    auto histogram = std::make_unique<Histogram>(_clusterClassifier->getClustersCount());
    auto histogramResults = histogram->build(samples, featuresClusters);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::VOCABULARY_COMPUTATION));


    // --- STAGE 4 --- Scale data
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::NORMALIZATION));
    _scaler->transform(histogramResults);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::NORMALIZATION));


    // --- STAGE 5 --- Train model
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLASSIFIER_EXECUTION));
    _domainClassifier->train(histogramResults, labels);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLASSIFIER_EXECUTION));
    _bus->event(TrainingCompleted());
}

float DetectionEngine::predict(Sample &sample)
{
    // --- START --- //
    // --- STAGE 1 --- Compute features //

    if (!isModelReady()) {
        throw app_exception(errors::codes::models_not_loaded);
    }

    _bus->event(PredictionStarted());
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::FEATURES_COMPUTATION));
    sample.computeFeatures(_featuresExtractor);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::FEATURES_COMPUTATION));

    if (sample.countDescriptors() < _clusterClassifier->getClustersCount()) {
        _bus->event(PredictionCompleted(STATUS::FAILED));

        throw app_exception(errors::codes::not_enough_descriptors);
    }

    // --- STAGE 2 --- Cluster features //
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLUSTERING));
    auto features = sample.getDescriptors();
    auto featuresClusters = _clusterClassifier->predict(features);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLUSTERING));


    // --- STAGE 3 --- Build vocabulary
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::VOCABULARY_COMPUTATION));
    auto histogram = std::make_unique<Histogram>(_clusterClassifier->getClustersCount());
    auto histogramResults = histogram->build(sample, featuresClusters);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::VOCABULARY_COMPUTATION));


    // --- STAGE 4 --- Scale data
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::NORMALIZATION));
    _scaler->transform(histogramResults);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::NORMALIZATION));


    // --- STAGE 5 -- Predict
    _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLASSIFIER_EXECUTION));
    float labelId = _domainClassifier->predict(histogramResults);
    _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLASSIFIER_EXECUTION));

    PredictionCompleted event;
    event.status = STATUS::CORRECT;
    event.outcomeLabelId = static_cast<int>(labelId);
    event.virusFamilyLabel = getLabelName(event.outcomeLabelId);
    event.totalExtractedFeatures = sample.countDescriptors();
    event.filepath = sample.getPath();

    _bus->event(event);

    return labelId;
}

bool DetectionEngine::isInitialized()
{
    return
            _clusterClassifier != nullptr &&
            _featuresExtractor != nullptr &&
            _domainClassifier != nullptr &&
            _scaler != nullptr &&
            _bus != nullptr;
}

bool DetectionEngine::isModelReady()
{
    return _domainClassifier->isTrained() && _clusterClassifier->isTrained();
}

void DetectionEngine::setClusterClassifier(std::shared_ptr<ClusterClassifier>&& clusterClassifier)
{
    _clusterClassifier = clusterClassifier;
}

void DetectionEngine::setFeaturesExtractor(std::shared_ptr<FeaturesExtractor>&& featuresExtractor)
{
    _featuresExtractor = featuresExtractor;
}

void DetectionEngine::setDomainClassifier(std::shared_ptr<DomainClassifier>&& domainClassifier)
{
    _domainClassifier = domainClassifier;
}

void DetectionEngine::setDataScaler(std::shared_ptr<Scaler>&& scaler)
{
    _scaler = scaler;
}

void DetectionEngine::setConfigProvider(std::shared_ptr<ConfigProvider> &&configProvider)
{
    _configProvider = configProvider;
}

std::shared_ptr<ConfigProvider>& DetectionEngine::config()
{
    return _configProvider;
}

void DetectionEngine::saveCurrentConfiguration()
{
    auto ssid = Uuid::generate();
    auto ccid = Uuid::generate() += ".yaml";
    auto dcid = Uuid::generate() += ".yaml";

    auto ccPath = _configProvider->generatePath(ccid);
    auto dcPath = _configProvider->generatePath(dcid);

    _clusterClassifier->save(ccPath);
    _domainClassifier->save(dcPath);

    Config config;
    config.id = ssid;
    config.clusterModel = ccPath;
    config.predictionModel = dcPath;

    _configProvider->addConfiguration(config);
    _configProvider->save();
}

void DetectionEngine::loadConfiguration(const std::string& cfgId)
{
    auto config = _configProvider->getConfiguration(cfgId);

    _clusterClassifier->load(config.clusterModel);
    _domainClassifier->load(config.predictionModel);
}

std::string DetectionEngine::getLabelName(int labelId)
{
    std::map<int, std::string> labels;
    labels[1] = "Ramnit";
    labels[2] = "Lollipop";
    labels[3] = "Kelihos_ver3";
    labels[4] = "Vundo";
    labels[5] = "Simda";
    labels[6] = "Tracur";
    labels[7] = "Kelihos_ver1";
    labels[8] = "Obfuscator.ACY";
    labels[9] = "Gatak";

    return labels[labelId];
}