//
// Created by pp on 10.01.19.
//

#include "../includes/DetectionEngine.hpp"
#include "../includes/Histogram.hpp"
#include "../../exception.hpp"
#include "../../utility/Uuid.hpp"

struct DetectorExecutionLog
{
    std::vector<Sample> invalidSamples;
};

void DetectionEngine::train(const std::unique_ptr<Dataset> &dataset)
{
    if (!isInitialized()) {
        throw app_exception(errors::codes::engine_not_initialized);
    }

    auto tracker = DetectorExecutionLog();

    // --- START --- //
    // --- STAGE 1 --- Compute features /
    event(TrainingStarted()); //_bus->event(TrainingStarted());
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::FEATURES_COMPUTATION)); //_bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::FEATURES_COMPUTATION));

    cv::Mat descriptors;
    cv::Mat labels;
    auto samples = dataset->getSamples();

    for (auto it = samples.begin(); it != samples.end(); ++it) {
        it->computeFeatures(_featuresExtractor);

        if (it->countDescriptors() < _clusterClassifier->getClustersCount()) {
            tracker.invalidSamples.push_back(*it);
            samples.erase(it);
            continue;
        }
        descriptors.push_back(it->getDescriptors());
    }

    for (auto& s : samples) {
        labels.push_back(s.getLabelId());
    }
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::FEATURES_COMPUTATION)); // _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::FEATURES_COMPUTATION));


    // --- STAGE 2 --- Cluster features
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLUSTERING)); //_bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLUSTERING));
    auto featuresClusters = _clusterClassifier->cluster(descriptors);
    _clusterClassifier->train(descriptors, featuresClusters);
    featuresClusters = _clusterClassifier->predict(descriptors);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLUSTERING)); // _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLUSTERING));


    // --- STAGE 3 --- Build vocabulary
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::VOCABULARY_COMPUTATION)); // _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::VOCABULARY_COMPUTATION));
    auto histogram = std::make_unique<Histogram>(_clusterClassifier->getClustersCount());
    auto histogramResults = histogram->build(samples, featuresClusters);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::VOCABULARY_COMPUTATION)); //_bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::VOCABULARY_COMPUTATION));


    // --- STAGE 4 --- Scale data
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::NORMALIZATION)); // _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::NORMALIZATION));
    _scaler->transform(histogramResults);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::NORMALIZATION));// _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::NORMALIZATION));


    // --- STAGE 5 --- Train model
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLASSIFIER_EXECUTION)); //_bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLASSIFIER_EXECUTION));
    _domainClassifier->train(histogramResults, labels);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLASSIFIER_EXECUTION)); //_bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLASSIFIER_EXECUTION));
    event(TrainingCompleted()); // _bus->event(TrainingCompleted());
}

float DetectionEngine::predict(Sample &sample)
{
    // --- START --- //
    // --- STAGE 1 --- Compute features //
    isSilentMode = true;
    if (!isModelReady()) {
        throw app_exception(errors::codes::models_not_loaded);
    }

    event(PredictionStarted()); //_bus->event(PredictionStarted());
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::FEATURES_COMPUTATION)); // _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::FEATURES_COMPUTATION));
    sample.computeFeatures(_featuresExtractor);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::FEATURES_COMPUTATION)); //_bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::FEATURES_COMPUTATION));

    if (sample.countDescriptors() < _clusterClassifier->getClustersCount()) {
        event(PredictionCompleted(STATUS::FAILED)); // _bus->event(PredictionCompleted(STATUS::FAILED));

        throw app_exception(errors::codes::not_enough_descriptors);
    }

    // --- STAGE 2 --- Cluster features //
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLUSTERING)); //_bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLUSTERING));
    auto features = sample.getDescriptors();
    auto featuresClusters = _clusterClassifier->predict(features);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLUSTERING)); // _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLUSTERING));


    // --- STAGE 3 --- Build vocabulary
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::VOCABULARY_COMPUTATION)); // _bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::VOCABULARY_COMPUTATION));
    auto histogram = std::make_unique<Histogram>(_clusterClassifier->getClustersCount());
    auto histogramResults = histogram->build(sample, featuresClusters);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::VOCABULARY_COMPUTATION)); //_bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::VOCABULARY_COMPUTATION));


    // --- STAGE 4 --- Scale data
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::NORMALIZATION)); //_bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::NORMALIZATION));
    _scaler->transform(histogramResults);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::NORMALIZATION)); // _bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::NORMALIZATION));


    // --- STAGE 5 -- Predict
    event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLASSIFIER_EXECUTION)); //_bus->event(StageChanged(STAGE_STATE::STARTED, STAGE_TYPE::CLASSIFIER_EXECUTION));
    float labelId = _domainClassifier->predict(histogramResults);
    event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLASSIFIER_EXECUTION)); //_bus->event(StageChanged(STAGE_STATE::COMPLETED, STAGE_TYPE::CLASSIFIER_EXECUTION));

    PredictionCompleted ev;
    ev.status = STATUS::CORRECT;
    ev.outcomeLabelId = static_cast<int>(labelId);
    ev.virusFamilyLabel = getLabelName(ev.outcomeLabelId);
    ev.totalExtractedFeatures = sample.countDescriptors();
    ev.filepath = sample.getPath();
    ev.filename = sample.getName();

    event(ev); //_bus->event(event);

    return labelId;
}

void DetectionEngine::test(const std::unique_ptr<Dataset> &dataset)
{
    event(TestStarted()); //_bus->event(TrainingStarted());

    isSilentMode = true;

    std::vector<std::string> rejectedFiles;
    auto samples = dataset->getSamples();

    int good = 0;
    int bad = 0;
    int totalFiles = samples.size();

    for (auto it = samples.begin(); it != samples.end(); ++it) {
        try {
            auto ret = predict(*it);

            if (static_cast<int>(ret) == it->getLabelId()) {
                std::cout << "1" << std::endl;
                good++;
            } else {
                std::cout << "0" << std::endl;
                bad++;
            }

        } catch (app_exception& e) {
            rejectedFiles.push_back(it->getName());
        }
    }

    isSilentMode = false;

    TestCompleted ev;
    ev.goodPredicted = good;
    ev.badPredicted = bad;
    ev.rejectedFiles = rejectedFiles;
    ev.totalFiles = totalFiles;
    ev.accurracy = (static_cast<double>(good) / static_cast<double>(ev.totalFiles)) * 100;

    event(ev);
}

bool DetectionEngine::isInitialized()
{
    return
            _clusterClassifier != nullptr &&
            _featuresExtractor != nullptr &&
            _domainClassifier != nullptr &&
            _scaler != nullptr &&
            _bus != nullptr;
}

bool DetectionEngine::isModelReady()
{
    return _domainClassifier->isTrained() && _clusterClassifier->isTrained();
}

void DetectionEngine::setClusterClassifier(std::shared_ptr<ClusterClassifier>&& clusterClassifier)
{
    _clusterClassifier = clusterClassifier;
}

void DetectionEngine::setFeaturesExtractor(std::shared_ptr<FeaturesExtractor>&& featuresExtractor)
{
    _featuresExtractor = featuresExtractor;
}

void DetectionEngine::setDomainClassifier(std::shared_ptr<DomainClassifier>&& domainClassifier)
{
    _domainClassifier = domainClassifier;
}

void DetectionEngine::setDataScaler(std::shared_ptr<Scaler>&& scaler)
{
    _scaler = scaler;
}

void DetectionEngine::setConfigProvider(std::shared_ptr<ConfigProvider> &&configProvider)
{
    _configProvider = configProvider;
}

std::shared_ptr<ConfigProvider>& DetectionEngine::config()
{
    return _configProvider;
}

void DetectionEngine::saveCurrentConfiguration()
{
    auto ssid = Uuid::generate();
    auto ccid = Uuid::generate() += ".yaml"; // cluster classifier filename
    auto dcid = Uuid::generate() += ".yaml"; // domain classifier filename
    auto scid = Uuid::generate() += ".json"; // standard scaler filename

    // paths for files
    // config provider has root dir path
    // provider -> ( root_dir + filename) -> root_dir/filename

    auto ccPath = _configProvider->generatePath(ccid);
    auto dcPath = _configProvider->generatePath(dcid);
    auto scPath = _configProvider->generatePath(scid);

    _clusterClassifier->save(ccPath);
    _domainClassifier->save(dcPath);
    _scaler->save(scPath);

    Config config;
    config.id = ssid;
    config.clusterModel = ccPath;
    config.predictionModel = dcPath;
    config.scaler = scPath;

    _configProvider->addConfiguration(config);
    _configProvider->save();
}

void DetectionEngine::loadConfiguration(const std::string& cfgId)
{
    auto config = _configProvider->getConfiguration(cfgId);

    _clusterClassifier->load(config.clusterModel);
    _domainClassifier->load(config.predictionModel);
    _scaler->load(config.scaler);
}

std::string DetectionEngine::getLabelName(int labelId)
{
    std::map<int, std::string> labels;
    labels[1] = "Ramnit";
    labels[2] = "Lollipop";
    labels[3] = "Kelihos_ver3";
    labels[4] = "Vundo";
    labels[5] = "Simda";
    labels[6] = "Tracur";
    labels[7] = "Kelihos_ver1";
    labels[8] = "Obfuscator.ACY";
    labels[9] = "Gatak";

    return labels[labelId];
}