//
// Created by pp on 26.01.19.
//

#ifndef THESIS_JSONDESERIALIZER_HPP
#define THESIS_JSONDESERIALIZER_HPP
#include <vector>
#include <sstream>
#include <string>
#include <memory>


template <typename T>
class JsonDeserializer
{
    const static char LIST_OPEN = '[';
    const static char LIST_CLOSE = ']';
    const static char SEPARATOR = ',';
    const static char OBJ_OPEN = '{';
    const static char OBJ_CLOSE = '}';
    const static char MARK = '\"';

    class Token {
    public:
        enum STATES { EMPTY = '_'};

        char value;
    };

    class Tokenizer
    {
    public:
        explicit Tokenizer(const std::string& s)
                : stream(s)
        {}
        Token getToken()
        {
            Token t {};

            if (stream.eof()) {
                t.value = Token::STATES::EMPTY;
            } else {
                stream >> t.value;
            }

            return t;
        }
        void put_back(char c) {  stream.putback(c); }
    private:
        std::stringstream stream;
    };

    class Object
    {
    public:
        std::string value;
    };

public:
    explicit JsonDeserializer(const std::stringstream& stream)
        :tokenizer(Tokenizer(stream.str())), currentObj(0)
    {
        init();
    }
    ~JsonDeserializer() = default;

    virtual T deserializeObject() = 0;
    virtual std::vector<T> deserialize()
    {
        currentObj = 0;
        std::vector<T> vec;

        for (int i = 0; i < objects.size(); ++i) {
            auto deserializedObject = deserializeObject();

            vec.push_back(deserializedObject);
            currentObj++;
        }

        return vec;
    }

private:
    Tokenizer tokenizer;
    std::vector<Object> objects;
    int currentObj;

private:
    std::string loadObject()
    {
        std::vector<char> v;
        int count = 0;

        auto token = tokenizer.getToken();

        if (token.value != OBJ_OPEN) {
            throw std::runtime_error("Invalid open bracket for object");
        }

        token = tokenizer.getToken();

        do {
            if (token.value == Token::STATES::EMPTY) {
                throw std::runtime_error("Invalid configuration format for object.");
            }

            if (token.value == SEPARATOR) {
                if (count != 4) {
                    throw std::runtime_error("Invalid number of apostrophes.");
                } else {
                    count = 0;
                }
            }

            if (token.value == MARK) {
                count++;
            }

            v.push_back(token.value);

            if (count == 4) {
                token = tokenizer.getToken();

                if (token.value == OBJ_CLOSE) {
                    break;
                } else if (token.value != SEPARATOR) {
                    throw std::runtime_error("Invalid separator between properties");
                }

                tokenizer.put_back(token.value);
            }

            token = tokenizer.getToken();

        } while (token.value != OBJ_CLOSE);

        return std::string(v.begin(), v.end());
    }

    void init()
    {
        auto token = tokenizer.getToken();

        switch (token.value) {
            case LIST_OPEN: {
                while (true) {
                    std::string obj = loadObject();

                    Object object;
                    object.value = obj;

                    objects.push_back(object);

                    token = tokenizer.getToken();

                    if (token.value == LIST_CLOSE) {
                        break;
                    }

                    if (token.value != SEPARATOR) {
                        throw std::runtime_error("Invalid configuration format.");
                    }

                    if (token.value == Token::STATES::EMPTY) {
                        throw std::runtime_error("Invalid configuration format.");
                    }
                }
                break;
            }

            case OBJ_OPEN: {
                tokenizer.put_back(token.value);
                std::string obj = loadObject();

                Object object;
                object.value = obj;

                objects.push_back(object);
                break;
            }
            default:
                throw std::runtime_error("Invalid configuration format");
        }
    }

protected:
    template <typename TProp>
    TProp property(const std::string&  prop)
    {
        auto object = objects.at(currentObj);

        int idx = static_cast<int>(object.value.find(prop));

        if (idx == std::string::npos) {
            throw std::runtime_error("Property does not exist");
        }

        std::vector<int> indexes;

        for (int i = idx - 1; indexes.size() != 4; ++i) {
            if (object.value[i] == MARK) {
                indexes.push_back(i);
            }
        }

        auto substr = object.value.substr(indexes[2] + 1, indexes[3] - 1 - indexes[2]);

        std::stringstream stream(substr);

        TProp value;

        stream >> value;

        return value;
    }
};


#endif //THESIS_JSONDESERIALIZER_HPP
