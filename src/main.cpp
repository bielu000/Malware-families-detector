#include <utility>
#include <iostream>
#include <vector>
#include <memory>
#include <fstream>
#include <map>
#include <exception>
#include "headers.hpp"
#include <map>
#include <chrono>

/* Notice:
 *  - KNCLusterClassifier->predict returns matrix with type CV_32S but orignally it should returns CV32_F
 *    I added casting because Histogram needs matrix with type CV32_s, maybe I should change it and do casting in
 *    histogram?
 *
 *
 */

/*
 * Todo:
 *  - change all includes to only required, e.g. if it is need for mat include only mat not whole cv
 */




int main() {
    auto time_start = std::chrono::high_resolution_clock::now();

//    const std::string trainLabelsSource = "../../dataset/abstract/train/labels.csv";
//    const std::string trainDataRootSource = "../../dataset/abstract/train/dataset";
//
//    const std::string testLabelsSource = "../../dataset/abstract/test/labels.csv";
//    const std::string testDataRootSource = "../../dataset/abstract/test/dataset";

//    const std::string trainLabelsSource = "../../dataset/ml1/train/trainLabels-5900.csv";
//    const std::string trainDataRootSource = "../../dataset/ml1/train";
//
//    const std::string testLabelsSource = "../../dataset/ml1/test/testLabels-5900.csv";
//    const std::string testDataRootSource = "../../dataset/ml1/test";

    const std::string trainLabelsSource = "../../dataset/ml2/train/trainLabels-90.csv";
    const std::string trainDataRootSource = "../../dataset/ml2/train";

    const std::string testLabelsSource = "../../dataset/ml2/test/testLabels-45.csv";
    const std::string testDataRootSource = "../../dataset/ml2/test";


    auto detector = std::make_unique<DetectionEngine>();
    detector->setClusterClassifier(std::make_shared<KNearestClusterClassifier>(100));
    detector->setFeaturesExtractor(std::make_shared<OpenCvSurfExtractor>());
    detector->setDomainClassifier(std::make_shared<SVCDomainClassifier>());
    detector->setDataScaler(std::make_shared<StandardScaler>());

    auto trainDataset = std::make_unique<Dataset>(trainLabelsSource, trainDataRootSource);
    detector->train(trainDataset);

    auto testDataset = std::make_unique<Dataset>(testLabelsSource, testDataRootSource);

    int allSamples = static_cast<int>(testDataset->getSamples().size());
    int good = 0;

    for (auto& sample : testDataset->getSamples()) {
        int result = static_cast<int>(detector->predict(sample));

        if (result == -99.1) {
            std::cout << "Test descriptors not enough" << std::endl;

            continue;
        }

        if (result == sample.getLabelId()) {
            good++;
        }
    }

    auto time_end = std::chrono::high_resolution_clock::now();
    auto sub = std::chrono::duration_cast<std::chrono::seconds>(time_end - time_start);

    std::cout << "Learning and testing time: " << sub.count() << " seconds." << std::endl;
    std::cout << good << "/" << allSamples << " was classified properly." << std::endl;
    std::cout << "Accurracy: " << (good / allSamples) * 100 << " %" << std::endl;

    return 0;
}