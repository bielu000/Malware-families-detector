#include <utility>
#include <iostream>
#include <vector>
#include <memory>
#include <fstream>
#include <map>
#include <exception>
#include "headers.hpp"
#include <map>
#include <chrono>

#include "gui/include/qtappcontroller.hpp"
#include "engine/includes/DetectorSupervisor.hpp"
#include "engine/includes/FileConfigProvider.hpp"
#include "utility/Uuid.hpp"

#include <experimental/filesystem>

namespace fs = std::experimental::filesystem;

/* Notice:
 *  - KNCLusterClassifier->predict returns matrix with type CV_32S but orignally it should returns CV32_F
 *    I added casting because Histogram needs matrix with type CV32_s, maybe I should change it and do casting in
 *    histogram?
 *
 *
 */

/*
 * Todo:
 *  - change all includes to only required, e.g. if it is need for mat include only mat not whole cv
 *  - change test/train options window to *dialog
 */




int main(int argc, char *argv[]) {
//    auto time_start = std::chrono::high_resolution_clock::now();
//
////    const std::string trainLabelsSource = "../../dataset/abstract/train/labels.csv";
////    const std::string trainDataRootSource = "../../dataset/abstract/train/dataset";
////
////    const std::string testLabelsSource = "../../dataset/abstract/test/labels.csv";
////    const std::string testDataRootSource = "../../dataset/abstract/test/dataset";
//
//    const std::string trainLabelsSource = "../../dataset/ml1/train/trainLabels-5900.csv";
//    const std::string trainDataRootSource = "../../dataset/ml1/train";
//
//    const std::string testLabelsSource = "../../dataset/ml1/test/testLabels-1500.csv";
//    const std::string testDataRootSource = "../../dataset/ml1/test";
//
    const std::string trainLabelsSource = "../../dataset/ml2/train/trainLabels-90.csv";
    const std::string trainDataRootSource = "../../dataset/ml2/train";

    const std::string testLabelsSource = "../../dataset/ml2/test/testLabels-45.csv";
    const std::string testDataRootSource = "../../dataset/ml2/test";
//
////    const std::string trainLabelsSource = "../../dataset/ml3/train/trainLabels-450.csv";
////    const std::string trainDataRootSource = "../../dataset/ml3/train";
////
////    const std::string testLabelsSource = "../../dataset/ml3/test/testLabels-280.csv";
////    const std::string testDataRootSource = "../../dataset/ml3/test";
//
////    const std::string trainLabelsSource = "../../dataset/ml4/train/trainLabels-900.csv";
////    const std::string trainDataRootSource = "../../dataset/ml4/train";
////
////    const std::string testLabelsSource = "../../dataset/ml4/test/testLabels-360.csv";
////    const std::string testDataRootSource = "../../dataset/ml4/test";
//


    auto bus = std::make_unique<MessageBus>();
    auto detector = std::make_unique<DetectionEngine>(bus);
    auto supervisor = std::make_shared<DetectorSupervisor>(detector, bus);
    detector->setClusterClassifier(std::make_shared<KMeansWrapper>(100));
    detector->setFeaturesExtractor(std::make_shared<OpenCvSurfExtractor>());
    detector->setDomainClassifier(std::make_shared<SVCDomainClassifier>());
    detector->setDataScaler(std::make_shared<StandardScaler>());
    detector->setConfigProvider(std::make_shared<FileConfigProvider>("config.json", "config"));

//    supervisor->train("asda", "dasd");
////
//    auto trainDataset = std::make_unique<Dataset>(trainLabelsSource, trainDataRootSource);
//    detector->train(trainDataset);
//
//    auto testDataset = std::make_unique<Dataset>(testLabelsSource, testDataRootSource);
//
//    int allSamples = static_cast<int>(testDataset->getSamples().size());
//    int good = 0;
//
//    std::fstream bad_labels("bad_labels_test", std::fstream::out);
//
//    for (auto& sample : testDataset->getSamples()) {
//        int result = static_cast<int>(detector->predict(sample));
//
//        if (result == -99.1) {
//            std::cout << "Test descriptors not enough" << std::endl;
//
//            continue;
//        }
//
//        if (result == sample.getLabelId()) {
//            good++;
//        } else {
//            bad_labels << sample.getName() << std::endl;
//        }
//    }
//
//    auto time_end = std::chrono::high_resolution_clock::now();
//    auto sub = std::chrono::duration_cast<std::chrono::seconds>(time_end - time_start);
//
//    double result = ((double)good / allSamples) * 100;
//
//    std::cout << "Learning and testing time: " << sub.count() << " seconds." << std::endl;
//    std::cout << good << "/" << allSamples << " was classified properly." << std::endl;
//    std::cout << "Accurracy: " << std::setprecision(2) << result << " %" << std::endl;

    auto appController = QtAppController(supervisor, bus);

    return appController.run(argc, argv);
}